## 1실전 자바 소프트웨어 개발

##### Chapter 2. 입출금 내역 분석기

###### 2.1 도전 과제

- 입출금 내역을 자동으로 분석해 재정 상태를 보여주는 소프트웨어

###### 2.2 목표

- 좋은 소프트웨어의 개발을 위한 기반이 무엇인지 학습
  - 1 개의 클래스로 문제를 구현하고 바뀌는 요구사항, 유지보수에 대응하며 기존 구조의 한계를 확인
  - 단일책임 원칙
  - 응집도/결합도의 특징

###### 2.3 입출금 내역 분석기 요구 사항 

- CSV 포맷으로 구성된 텍스트 형식의 거래 내역 파일

  ```
  30-01-2017,-100,Deliveroo
  30-01-2017,-50,Tesco
  01-02-2017,6000,Salary
  02-02-2017,2000,Royalties
  02-02-2017,-4000,Rent
  03-02-2017,3000,Tesco
  05-02-2017,-30,Cinema
  ```

  > 2장에서는 콤마로만 구분되었다고 가정

- 입출금 내역의 총 수입과 총 지출

- 위 결과가 양수인지 음수인지 파악

- 월 별 입출금 내역 건수

- 지출 상위 10건

- 가장 큰 지출 항목

###### 2.4 KISS 원칙

- 입출금 내역의 총 수입과 총 지출을 알아보기 위해 CSV 파일을 처리해 모든 금액의 합을 계산
- KISS: Keep it short and simple 원칙을 이용해 한 개의 클래스로 구현
- final 변수
  - final로 표시하면 어떤 객체의 상태가 바뀔 수 있고 바뀔 수 없는지 명확하게 구분할 수 있음
  - final을 적용해도 객체가 가변 상태를 포함하기 때문에 바뀌지 못하도록 강요할 수는 없음 
  - 추상 메서드의 메서드 파라미터에 final을 사용하면 실제 구현이 없어 키워드의 의미가 무력화됨
  - var 키워드가 등장하면서 final의 유용성이 감소함
- [예제 1. 모든 거래 내역의 합 계산하기](https://github.com/YeJi-Park/RealWorldSoftwareDevelopment/blob/main/src/chapter2/exam01/BankTransactionAnalyzerSimple.java)
- [예제 2. 1월 입출금 내역 합계 계산하기](https://github.com/YeJi-Park/RealWorldSoftwareDevelopment/blob/main/src/chapter2/exam02/BankTransactionAnalyzerSimple.java)

###### 2.5 코드 유지보수성과 안티 패턴 

- 코드를 구현할 때는 **코드 유지보수성**을 높이기 위해 노력함
  - 특정 기능을 담당하는 코드를 쉽게 찾을 수 있어야 함
  - 코드가 어떤 일을 수행하는지 쉽게 이해할 수 있어야 함
  - 새로운 기능을 쉽게 추가하거나 기존 기능을 쉽게 제거할 수 있어야 함
  - 캡슐화가 잘 되어 있어야 함: 사용자에게 세부 구현을 감춰 쉽게 코드를 이해하고 기능을 바꿀 수 있어야 함
- **안티 패턴**
  - 거대한 1 개의 클래스 때문에 코드를 이해하기 어려움
  - 코드 중복때문에 불안정하고 변화에 쉽게 망가짐
- 갓 클래스
  - 한 개의 파일에 모든 코드를 구현해 클래스의 목적이 무엇인지 이해하기 어려움
  - 기존 코드의 로직을 갱신해야 할 때 어떤 부분을 바꿔야 할 지 알기 힘듦
  - 단일 책임 원칙이 지켜지지 않아서 생기는 문제
- 코드 중복
  - 한 가지 문제만 해결하도록 하드코딩되어 있고, 여러 곳에 이 코드가 중복되어 있어 기존의 기능을 바꾸기 어려움
  - 중복된 코드를 모두 바꿔줘야 하고 새로운 버그가 발생할 가능성이 있음
  - 중복 배제(DRY) 원칙을 지켜 반복을 제거하면 로직을 바꿔도 여러 곳의 코드를 바꿔야 할 필요가 없음
- 현재 코드는 특정 데이터 형식만 지원하기 때문에 기능을 추가하거나 변경하기 위해서 많은 부분을 다시 바꿔야 함
- KISS 원칙을 지켜 코드를 간결하게 유지하는 것도 중요하지만 설계를 되돌아보고, 한 문제를 작은 개별 문제로 분리해 쉽게 관리할 수 있는지 파악해야 함

###### 2.6 단일 책임 원칙(SRP)

- 쉽게 관리하고 유지보수하는 코드를 구현하는 데 도움을 주는 포괄적인 소프트웨어 개발 지침
- 다음의 두 가지를 보완하기 위해 SRP를 적용
  - 한 클래스는 한 기능만 책임짐
  - 클래스가 바뀌는 이유는 오직 하나여야 함
- 일반적으로 클래스, 메서드에 적용
- 코드가 바뀌는 이유가 한 가지가 아니라면, 여러 장소에서 코드 변경이 발생하므로 코드 유지보수가 어려움
- 현재 메인 클래스는 여러 책임을 모두 포함하므로 이를 개별 분리해야 함
  - 입력 읽기
  - 주어진 형식의 입력 파싱
  - 결과 처리
  - 결과 리포트
- [예제 3. 파싱 로직을 추출해 한 클래스로 만듦](https://github.com/YeJi-Park/RealWorldSoftwareDevelopment/blob/main/src/chapter2/exam03/BankStatementCSVParser.java)
  - 다른 문제 구현에 활용할 수 있도록 CSV 파싱 로직을 새로운 클래스로 분리
- [예제 4. 입출금 내역 도메인 클래스](https://github.com/YeJi-Park/RealWorldSoftwareDevelopment/blob/main/src/chapter2/exam03/BankTransaction.java)
  - 도메인: 비즈니스 문제와 동일한 단어와 용어를 사용한다는 의미
  - 응용 프로그램의 다른 부분에서 입출금 내역 부분이라는 의미를 공유할 수 있어 유용함
- [예제 5. 6 입출금 내역 CSV 파서 사용하기](https://github.com/YeJi-Park/RealWorldSoftwareDevelopment/blob/main/src/chapter2/exam03/BankTransactionAnalyzer.java)
  - CSV Parser를 이용하도록 기존 코드를 리팩토링
  - BankTransaction 객체에서 직접 정보를 추출하기 때문에 내부 파싱을 알 필요가 없음
  - 메인 응용 프로그램에서 파싱 로직을 구현하는 부분이 사라져 새로운 요구사항이 들어와도 Parser 클래스로 캡슐화된 기능을 재사용해 구현함
  - 파싱 알고리즘 동작 방식을 바꿔야 해도 한 곳의 코드만 바꾸면 됨
  - BankTransaction 클래스를 사용해 다른 코드가 특정 데이터 형식에 의존하지 않게 됨
- 놀람 최소화 원칙: 누군가가 놀라 지 않도록 일관성을 유지하는 범위에서 코드를 구현할 것을 강조하는 원칙
- 메서드가 수행하는 일을 바로 이해할 수 있도록 자체 문서화를 제공하는 메서드명을 사용할 것
- 코드의 다른 부분이 파라미터 상태에 의존할 수 있으므로 파라미터의 상태를 바꾸지 않아야 함

